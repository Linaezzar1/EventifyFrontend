<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/MainActivity.kt" />
              <option name="originalContent" value="package com.eventify.app&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import com.eventify.app.ui.auth.LoginScreen&#10;import com.eventify.app.ui.auth.SignupScreen&#10;import com.eventify.app.ui.events.EventDetailScreen&#10;import com.eventify.app.ui.events.EventsListScreen&#10;import com.eventify.app.ui.events.CreateEventScreen&#10;import com.eventify.app.ui.theme.EventifyTheme&#10;import com.eventify.app.ui.events.EditEventScreen&#10;import com.eventify.app.ui.tasks.TaskListScreen&#10;import com.eventify.app.viewmodel.EventViewModel&#10;import com.eventify.app.model.Event&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContent {&#10;            EventifyTheme {&#10;                var isLoggedIn by remember { mutableStateOf(false) }&#10;                var isSignup by remember { mutableStateOf(false) }&#10;                var userName by remember { mutableStateOf(&quot;&quot;) }&#10;                var userToken by remember { mutableStateOf(&quot;&quot;) }&#10;                var userRole by remember { mutableStateOf(&quot;&quot;) }&#10;                var userEmail by remember { mutableStateOf(&quot;&quot;) }&#10;                var userId by remember { mutableStateOf(&quot;&quot;) }&#10;                val eventViewModel = remember { EventViewModel() }&#10;                var selectedEvent by remember { mutableStateOf&lt;Event?&gt;(null) }&#10;                var isCreatingEvent by remember { mutableStateOf(false) }&#10;                var isEditingEvent by remember { mutableStateOf(false) }&#10;                var showingTasksForEventId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;                when {&#10;                    !isLoggedIn &amp;&amp; !isSignup -&gt; LoginScreen(&#10;                        onLoginSuccess = { token, role, name, email, id -&gt;&#10;                            isLoggedIn = true&#10;                            userToken = token&#10;                            userRole = role&#10;                            userName = name&#10;                            userEmail = email&#10;                            userId = id&#10;                        },&#10;                        onSwitchToSignup = { isSignup = true }&#10;                    )&#10;                    !isLoggedIn &amp;&amp; isSignup -&gt; SignupScreen(&#10;                        onSignupSuccess = { name -&gt;&#10;                            isLoggedIn = true&#10;                            userName = name&#10;                        },&#10;                        onSwitchToLogin = { isSignup = false }&#10;                    )&#10;                    isCreatingEvent -&gt; CreateEventScreen(&#10;                        eventViewModel = eventViewModel,&#10;                        token = userToken,&#10;                        onEventCreated = {&#10;                            isCreatingEvent = false&#10;                            eventViewModel.loadEvents(userToken) { }&#10;                        }&#10;                    )&#10;                    isEditingEvent &amp;&amp; selectedEvent != null -&gt; EditEventScreen(&#10;                        event = selectedEvent!!,&#10;                        eventViewModel = eventViewModel,&#10;                        token = userToken,&#10;                        onEditFinished = {&#10;                            isEditingEvent = false&#10;                            selectedEvent = null&#10;                            eventViewModel.loadEvents(userToken) { }&#10;                        }&#10;                    )&#10;                    showingTasksForEventId != null -&gt; TaskListScreen(&#10;                        eventId = showingTasksForEventId!!,&#10;                        token = userToken,&#10;                        eventViewModel = eventViewModel,&#10;                        onBack = { showingTasksForEventId = null }&#10;                    )&#10;                    selectedEvent != null -&gt; EventDetailScreen(&#10;                        event = selectedEvent!!,&#10;                        userRole = userRole,&#10;                        userEmail = userEmail,&#10;                        userId = userId,&#10;                        token = userToken,&#10;                        eventViewModel = eventViewModel,&#10;                        onBack = { selectedEvent = null },&#10;                        onEventDeleted = {&#10;                            selectedEvent = null&#10;                            eventViewModel.loadEvents(userToken) { }&#10;                        },&#10;                        onEditEvent = { isEditingEvent = true },&#10;                        onShowTasks = { eventId -&gt; showingTasksForEventId = eventId } // Nouvel argument&#10;                    )&#10;                    else -&gt; EventsListScreen(&#10;                        eventViewModel = eventViewModel,&#10;                        token = userToken,&#10;                        userRole = userRole,&#10;                        onEventClick = { event -&gt; selectedEvent = event },&#10;                        onCreateEventClick = { isCreatingEvent = true },&#10;                        onLogout = {&#10;                            isLoggedIn = false&#10;                            isSignup = false&#10;                            userToken = &quot;&quot;&#10;                            userRole = &quot;&quot;&#10;                            userName = &quot;&quot;&#10;                            userEmail = &quot;&quot;&#10;                            userId = &quot;&quot;&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.eventify.app&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import com.eventify.app.ui.auth.LoginScreen&#10;import com.eventify.app.ui.auth.SignupScreen&#10;import com.eventify.app.ui.events.EventDetailScreen&#10;import com.eventify.app.ui.events.EventsListScreen&#10;import com.eventify.app.ui.events.CreateEventScreen&#10;import com.eventify.app.ui.theme.EventifyTheme&#10;import com.eventify.app.ui.events.EditEventScreen&#10;import com.eventify.app.ui.tasks.TaskListScreen&#10;import com.eventify.app.ui.participant.ParticipantMainScreen&#10;import com.eventify.app.viewmodel.EventViewModel&#10;import com.eventify.app.model.Event&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContent {&#10;            EventifyTheme {&#10;                var isLoggedIn by remember { mutableStateOf(false) }&#10;                var isSignup by remember { mutableStateOf(false) }&#10;                var userName by remember { mutableStateOf(&quot;&quot;) }&#10;                var userToken by remember { mutableStateOf(&quot;&quot;) }&#10;                var userRole by remember { mutableStateOf(&quot;&quot;) }&#10;                var userEmail by remember { mutableStateOf(&quot;&quot;) }&#10;                var userId by remember { mutableStateOf(&quot;&quot;) }&#10;                val eventViewModel = remember { EventViewModel() }&#10;                var selectedEvent by remember { mutableStateOf&lt;Event?&gt;(null) }&#10;                var isCreatingEvent by remember { mutableStateOf(false) }&#10;                var isEditingEvent by remember { mutableStateOf(false) }&#10;                var showingTasksForEventId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;                when {&#10;                    !isLoggedIn &amp;&amp; !isSignup -&gt; LoginScreen(&#10;                        onLoginSuccess = { token, role, name, email, id -&gt;&#10;                            isLoggedIn = true&#10;                            userToken = token&#10;                            userRole = role&#10;                            userName = name&#10;                            userEmail = email&#10;                            userId = id&#10;                        },&#10;                        onSwitchToSignup = { isSignup = true }&#10;                    )&#10;                    !isLoggedIn &amp;&amp; isSignup -&gt; SignupScreen(&#10;                        onSignupSuccess = { name -&gt;&#10;                            isLoggedIn = true&#10;                            userName = name&#10;                        },&#10;                        onSwitchToLogin = { isSignup = false }&#10;                    )&#10;                    // Interface Participant avec Drawer&#10;                    isLoggedIn &amp;&amp; userRole.trim().lowercase() == &quot;participant&quot; -&gt; ParticipantMainScreen(&#10;                        userName = userName,&#10;                        userEmail = userEmail,&#10;                        userId = userId,&#10;                        userToken = userToken,&#10;                        eventViewModel = eventViewModel,&#10;                        onLogout = {&#10;                            isLoggedIn = false&#10;                            isSignup = false&#10;                            userToken = &quot;&quot;&#10;                            userRole = &quot;&quot;&#10;                            userName = &quot;&quot;&#10;                            userEmail = &quot;&quot;&#10;                            userId = &quot;&quot;&#10;                        }&#10;                    )&#10;                    // Interface pour les autres rôles (organisateur, etc.)&#10;                    isCreatingEvent -&gt; CreateEventScreen(&#10;                        eventViewModel = eventViewModel,&#10;                        token = userToken,&#10;                        onEventCreated = {&#10;                            isCreatingEvent = false&#10;                            eventViewModel.loadEvents(userToken) { }&#10;                        }&#10;                    )&#10;                    isEditingEvent &amp;&amp; selectedEvent != null -&gt; EditEventScreen(&#10;                        event = selectedEvent!!,&#10;                        eventViewModel = eventViewModel,&#10;                        token = userToken,&#10;                        onEditFinished = {&#10;                            isEditingEvent = false&#10;                            selectedEvent = null&#10;                            eventViewModel.loadEvents(userToken) { }&#10;                        }&#10;                    )&#10;                    showingTasksForEventId != null -&gt; TaskListScreen(&#10;                        eventId = showingTasksForEventId!!,&#10;                        token = userToken,&#10;                        eventViewModel = eventViewModel,&#10;                        onBack = { showingTasksForEventId = null }&#10;                    )&#10;                    selectedEvent != null -&gt; EventDetailScreen(&#10;                        event = selectedEvent!!,&#10;                        userRole = userRole,&#10;                        userEmail = userEmail,&#10;                        userId = userId,&#10;                        token = userToken,&#10;                        eventViewModel = eventViewModel,&#10;                        onBack = { selectedEvent = null },&#10;                        onEventDeleted = {&#10;                            selectedEvent = null&#10;                            eventViewModel.loadEvents(userToken) { }&#10;                        },&#10;                        onEditEvent = { isEditingEvent = true },&#10;                        onShowTasks = { eventId -&gt; showingTasksForEventId = eventId } // Nouvel argument&#10;                    )&#10;                    else -&gt; EventsListScreen(&#10;                        eventViewModel = eventViewModel,&#10;                        token = userToken,&#10;                        userRole = userRole,&#10;                        onEventClick = { event -&gt; selectedEvent = event },&#10;                        onCreateEventClick = { isCreatingEvent = true },&#10;                        onLogout = {&#10;                            isLoggedIn = false&#10;                            isSignup = false&#10;                            userToken = &quot;&quot;&#10;                            userRole = &quot;&quot;&#10;                            userName = &quot;&quot;&#10;                            userEmail = &quot;&quot;&#10;                            userId = &quot;&quot;&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/Auth.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/Auth.kt" />
              <option name="originalContent" value="package com.eventify.app.model&#10;&#10;data class LoginRequest(&#10;    val email: String,&#10;    val password: String&#10;)&#10;&#10;data class SignupRequest(&#10;    val name: String,&#10;    val email: String,&#10;    val password: String,&#10;    val role: String&#10;)&#10;&#10;data class LoginResponse(&#10;    val token: String,&#10;    val role: String,&#10;    val name: String,&#10;    val email: String&#10;)&#10;" />
              <option name="updatedContent" value="package com.eventify.app.model&#10;&#10;data class LoginRequest(&#10;    val email: String,&#10;    val password: String&#10;)&#10;&#10;data class SignupRequest(&#10;    val name: String,&#10;    val email: String,&#10;    val password: String,&#10;    val role: String = &quot;participant&quot;&#10;)&#10;&#10;data class LoginResponse(&#10;    val token: String,&#10;    val role: String,&#10;    val name: String,&#10;    val email: String,&#10;    val userId: String? = null, // ID de l'utilisateur&#10;    val _id: String? = null // Alternative pour l'ID&#10;) {&#10;    // Helper pour obtenir l'ID quel que soit le champ retourné par le backend&#10;    fun getId(): String = userId ?: _id ?: &quot;&quot;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/Chatbot.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/Chatbot.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.eventify.app.model&#10;&#10;// Request et Response pour le Chatbot&#10;data class ChatbotRequest(&#10;    val message: String,&#10;    val conversationHistory: List&lt;ConversationMessage&gt;? = null&#10;)&#10;&#10;data class ConversationMessage(&#10;    val role: String, // &quot;user&quot; ou &quot;assistant&quot;&#10;    val content: String&#10;)&#10;&#10;data class ChatbotResponse(&#10;    val response: String, // Le backend renvoie &quot;response&quot; pas &quot;reply&quot;&#10;    val conversationId: Long? = null,&#10;    val source: String? = null, // &quot;ai-groq&quot; ou &quot;local&quot;&#10;    val userContext: UserContext? = null&#10;)&#10;&#10;data class UserContext(&#10;    val role: String,&#10;    val eventsCount: Int,&#10;    val pendingTasksCount: Int&#10;)&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/Event.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/Event.kt" />
              <option name="originalContent" value="package com.eventify.app.model&#10;&#10;data class Event(&#10;    val _id: String,&#10;    val title: String,&#10;    val description: String?,&#10;    val date: String,&#10;    val location: String?,&#10;    val createdBy: CreatedBy?,&#10;    val participants: List&lt;String&gt;? = emptyList()&#10;)&#10;&#10;data class CreatedBy(&#10;    val _id: String,&#10;    val name: String,&#10;    val email: String,&#10;    val role: String&#10;)&#10;&#10;data class EventRequest(&#10;    val title: String,&#10;    val description: String,&#10;    val date: String,&#10;    val location: String&#10;)&#10;" />
              <option name="updatedContent" value="package com.eventify.app.model&#10;&#10;data class Event(&#10;    val _id: String,&#10;    val title: String,&#10;    val description: String?,&#10;    val date: String,&#10;    val location: String?,&#10;    val createdBy: UserRef?,&#10;    val organizers: List&lt;String&gt;? = emptyList(),&#10;    val logisticManager: String? = null,&#10;    val communicationManager: String? = null,&#10;    val participants: List&lt;String&gt;? = emptyList(),&#10;    val logisticStaff: List&lt;String&gt;? = emptyList(),&#10;    val communicationStaff: List&lt;String&gt;? = emptyList(),&#10;    val visibility: String? = &quot;public&quot;, // &quot;public&quot; ou &quot;prive&quot;&#10;    val status: String? = &quot;brouillon&quot;, // &quot;brouillon&quot;, &quot;publie&quot;, &quot;annule&quot;&#10;    val createdAt: String? = null,&#10;    val updatedAt: String? = null&#10;)&#10;&#10;// Référence utilisateur simplifiée (pour createdBy, etc.)&#10;data class UserRef(&#10;    val _id: String,&#10;    val name: String,&#10;    val email: String,&#10;    val role: String&#10;)&#10;&#10;data class EventRequest(&#10;    val title: String,&#10;    val description: String?,&#10;    val date: String,&#10;    val location: String?,&#10;    val visibility: String? = &quot;public&quot;,&#10;    val status: String? = &quot;brouillon&quot;&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/Message.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/Message.kt" />
              <option name="updatedContent" value="package com.eventify.app.model&#10;&#10;// Model Message correspondant au backend&#10;data class Message(&#10;    val _id: String,&#10;    val sender: UserRef,&#10;    val receiver: UserRef,&#10;    val content: String,&#10;    val read: Boolean = false,&#10;    val createdAt: String&#10;)&#10;&#10;// Pour envoyer un message&#10;data class SendMessageRequest(&#10;    val receiverId: String,&#10;    val content: String&#10;)&#10;&#10;// Conversation (pour l'affichage dans la liste)&#10;data class Conversation(&#10;    val otherUser: UserRef,&#10;    val lastMessage: Message?,&#10;    val unreadCount: Int = 0&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/Notification.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/Notification.kt" />
              <option name="updatedContent" value="package com.eventify.app.model&#10;&#10;// Model Notification correspondant au backend&#10;data class Notification(&#10;    val _id: String,&#10;    val receiver: String, // userId&#10;    val sender: String? = null, // userId ou null si système&#10;    val type: String, // &quot;rappel_tache&quot;, &quot;validation_inscription&quot;, &quot;changement_horaire&quot;, &quot;alerte_retard&quot;&#10;    val event: String? = null, // eventId&#10;    val task: String? = null, // taskId&#10;    val message: String? = null,&#10;    val read: Boolean = false,&#10;    val createdAt: String? = null,&#10;    val updatedAt: String? = null&#10;)&#10;&#10;// Types de notifications&#10;object NotificationType {&#10;    const val RAPPEL_TACHE = &quot;rappel_tache&quot;&#10;    const val VALIDATION_INSCRIPTION = &quot;validation_inscription&quot;&#10;    const val CHANGEMENT_HORAIRE = &quot;changement_horaire&quot;&#10;    const val ALERTE_RETARD = &quot;alerte_retard&quot;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/Task.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/Task.kt" />
              <option name="originalContent" value="package com.eventify.app.model&#10;&#10;data class Task(&#10;    val _id: String,&#10;    val title: String,&#10;    val description: String?,&#10;    val status: String,&#10;    val assignedTo: User?,&#10;    val dueDate: String?,&#10;    val event: String,&#10;    val createdBy: User?&#10;)&#10;" />
              <option name="updatedContent" value="package com.eventify.app.model&#10;&#10;data class Task(&#10;    val _id: String,&#10;    val title: String,&#10;    val description: String?,&#10;    val status: String, // &quot;en_attente&quot;, &quot;en_cours&quot;, &quot;termine&quot;&#10;    val assignedTo: UserRef?,&#10;    val dueDate: String?,&#10;    val event: String, // eventId&#10;    val createdBy: UserRef?,&#10;    val createdAt: String? = null,&#10;    val updatedAt: String? = null&#10;)&#10;&#10;// Statuts possibles pour les tâches&#10;object TaskStatus {&#10;    const val EN_ATTENTE = &quot;en_attente&quot;&#10;    const val EN_COURS = &quot;en_cours&quot;&#10;    const val TERMINE = &quot;termine&quot;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/User.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/model/User.kt" />
              <option name="updatedContent" value="package com.eventify.app.model&#10;&#10;// Model User complet correspondant au backend&#10;data class User(&#10;    val _id: String,&#10;    val name: String,&#10;    val email: String,&#10;    val role: String, // &quot;participant&quot;, &quot;organisateur&quot;, &quot;logistique&quot;, &quot;communication&quot;&#10;    val avatarUrl: String? = null,&#10;    val notificationPreferences: NotificationPreferences? = null,&#10;    val createdAt: String? = null,&#10;    val updatedAt: String? = null&#10;)&#10;&#10;data class NotificationPreferences(&#10;    val email: Boolean = true,&#10;    val push: Boolean = true&#10;)&#10;&#10;// Pour les mises à jour de profil&#10;data class UpdateProfileRequest(&#10;    val name: String? = null,&#10;    val avatarUrl: String? = null,&#10;    val notificationPreferences: NotificationPreferences? = null&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/network/ApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/network/ApiService.kt" />
              <option name="originalContent" value="package com.eventify.app.network&#10;&#10;import com.eventify.app.model.*&#10;import retrofit2.Response&#10;import retrofit2.http.*&#10;&#10;interface ApiService {&#10;    @POST(&quot;api/auth/login&quot;)&#10;    suspend fun login(@Body loginRequest: LoginRequest): LoginResponse&#10;&#10;    @POST(&quot;api/auth/signup&quot;)&#10;    suspend fun signup(@Body signupRequest: SignupRequest): Response&lt;Unit&gt;&#10;&#10;    @GET(&quot;api/events&quot;)&#10;    suspend fun getEvents(@Header(&quot;Authorization&quot;) token: String): List&lt;Event&gt;&#10;&#10;    @GET(&quot;api/events/{id}&quot;)&#10;    suspend fun getEventById(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) id: String&#10;    ): Event&#10;&#10;    @POST(&quot;api/events&quot;)&#10;    suspend fun createEvent(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body eventRequest: EventRequest&#10;    ): Event&#10;&#10;    @PUT(&quot;api/events/{id}&quot;)&#10;    suspend fun updateEvent(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) id: String,&#10;        @Body eventRequest: EventRequest&#10;    ): Event&#10;&#10;    @DELETE(&quot;api/events/{id}&quot;)&#10;    suspend fun deleteEvent(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) id: String&#10;    ): Response&lt;Unit&gt;&#10;&#10;    @POST(&quot;api/events/{id}/join&quot;)&#10;    suspend fun joinEvent(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) eventId: String&#10;    ): Response&lt;Unit&gt;&#10;&#10;    @HTTP(method = &quot;DELETE&quot;, path = &quot;api/events/{id}/join&quot;, hasBody = false)&#10;    suspend fun leaveEvent(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) eventId: String&#10;    ): Response&lt;Unit&gt;&#10;&#10;    @GET(&quot;api/events/{id}/participants&quot;)&#10;    suspend fun getParticipants(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) eventId: String&#10;    ): List&lt;User&gt;&#10;&#10;    @POST(&quot;api/events/{eventId}/tasks&quot;)&#10;    suspend fun createTask(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;eventId&quot;) eventId: String,&#10;        @Body taskRequest: TaskRequest&#10;    ): Task&#10;&#10;    @GET(&quot;api/events/{eventId}/tasks&quot;)&#10;    suspend fun getTasksForEvent(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;eventId&quot;) eventId: String&#10;    ): List&lt;Task&gt;&#10;&#10;    @PUT(&quot;api/events/tasks/{taskId}&quot;)&#10;    suspend fun updateTask(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;taskId&quot;) taskId: String,&#10;        @Body taskRequest: TaskRequest&#10;    ): Task&#10;&#10;    @DELETE(&quot;api/events/tasks/{taskId}&quot;)&#10;    suspend fun deleteTask(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;taskId&quot;) taskId: String&#10;    ): Response&lt;Unit&gt;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.eventify.app.network&#10;&#10;import com.eventify.app.model.*&#10;import retrofit2.Response&#10;import retrofit2.http.*&#10;&#10;interface ApiService {&#10;    &#10;    // ==================== AUTH ====================&#10;    @POST(&quot;api/auth/login&quot;)&#10;    suspend fun login(@Body loginRequest: LoginRequest): LoginResponse&#10;&#10;    @POST(&quot;api/auth/signup&quot;)&#10;    suspend fun signup(@Body signupRequest: SignupRequest): Response&lt;Unit&gt;&#10;&#10;    // ==================== USERS ====================&#10;    @GET(&quot;api/users&quot;)&#10;    suspend fun getAllUsers(@Header(&quot;Authorization&quot;) token: String): List&lt;User&gt;&#10;&#10;    @DELETE(&quot;api/users/{id}&quot;)&#10;    suspend fun deleteUser(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) userId: String&#10;    ): Response&lt;Unit&gt;&#10;&#10;    // ==================== EVENTS ====================&#10;    @GET(&quot;api/events&quot;)&#10;    suspend fun getEvents(@Header(&quot;Authorization&quot;) token: String): List&lt;Event&gt;&#10;&#10;    @GET(&quot;api/events/{id}&quot;)&#10;    suspend fun getEventById(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) id: String&#10;    ): Event&#10;&#10;    @POST(&quot;api/events&quot;)&#10;    suspend fun createEvent(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body eventRequest: EventRequest&#10;    ): Event&#10;&#10;    @PUT(&quot;api/events/{id}&quot;)&#10;    suspend fun updateEvent(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) id: String,&#10;        @Body eventRequest: EventRequest&#10;    ): Event&#10;&#10;    @DELETE(&quot;api/events/{id}&quot;)&#10;    suspend fun deleteEvent(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) id: String&#10;    ): Response&lt;Unit&gt;&#10;&#10;    // Inscriptions participant&#10;    @POST(&quot;api/events/{id}/join&quot;)&#10;    suspend fun joinEvent(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) eventId: String&#10;    ): Response&lt;Unit&gt;&#10;&#10;    @HTTP(method = &quot;DELETE&quot;, path = &quot;api/events/{id}/join&quot;, hasBody = false)&#10;    suspend fun leaveEvent(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) eventId: String&#10;    ): Response&lt;Unit&gt;&#10;&#10;    @GET(&quot;api/events/{id}/participants&quot;)&#10;    suspend fun getParticipants(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) eventId: String&#10;    ): List&lt;User&gt;&#10;&#10;    // ==================== TASKS ====================&#10;    @POST(&quot;api/events/{eventId}/tasks&quot;)&#10;    suspend fun createTask(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;eventId&quot;) eventId: String,&#10;        @Body taskRequest: TaskRequest&#10;    ): Task&#10;&#10;    @GET(&quot;api/events/{eventId}/tasks&quot;)&#10;    suspend fun getTasksForEvent(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;eventId&quot;) eventId: String&#10;    ): List&lt;Task&gt;&#10;&#10;    @PUT(&quot;api/events/{eventId}/tasks/{taskId}&quot;)&#10;    suspend fun updateTask(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;eventId&quot;) eventId: String,&#10;        @Path(&quot;taskId&quot;) taskId: String,&#10;        @Body taskRequest: TaskRequest&#10;    ): Task&#10;&#10;    @DELETE(&quot;api/events/{eventId}/tasks/{taskId}&quot;)&#10;    suspend fun deleteTask(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;eventId&quot;) eventId: String,&#10;        @Path(&quot;taskId&quot;) taskId: String&#10;    ): Response&lt;Unit&gt;&#10;&#10;    // ==================== MESSAGES ====================&#10;    @POST(&quot;api/messages&quot;)&#10;    suspend fun sendMessage(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body messageRequest: SendMessageRequest&#10;    ): Message&#10;&#10;    @GET(&quot;api/messages&quot;)&#10;    suspend fun getInbox(@Header(&quot;Authorization&quot;) token: String): List&lt;Message&gt;&#10;&#10;    @GET(&quot;api/messages/{otherUserId}&quot;)&#10;    suspend fun getConversation(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;otherUserId&quot;) otherUserId: String&#10;    ): List&lt;Message&gt;&#10;&#10;    // ==================== NOTIFICATIONS ====================&#10;    @GET(&quot;api/notifications&quot;)&#10;    suspend fun getMyNotifications(@Header(&quot;Authorization&quot;) token: String): List&lt;Notification&gt;&#10;&#10;    @PUT(&quot;api/notifications/{id}/read&quot;)&#10;    suspend fun markNotificationAsRead(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Path(&quot;id&quot;) notificationId: String&#10;    ): Response&lt;Unit&gt;&#10;&#10;    // ==================== CHATBOT ====================&#10;    @POST(&quot;api/chatbot/chat&quot;)&#10;    suspend fun chatWithBot(&#10;        @Header(&quot;Authorization&quot;) token: String,&#10;        @Body chatRequest: ChatbotRequest&#10;    ): ChatbotResponse&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/participant/ParticipantChatbotScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/participant/ParticipantChatbotScreen.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.eventify.app.ui.participant&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material.icons.filled.SmartToy&#10;import androidx.compose.material.icons.automirrored.filled.Send&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.eventify.app.viewmodel.ChatbotViewModel&#10;import com.eventify.app.viewmodel.ChatMessage&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ParticipantChatbotScreen(&#10;    token: String,&#10;    chatbotViewModel: ChatbotViewModel,&#10;    onMenuClick: () -&gt; Unit&#10;) {&#10;    var messageText by remember { mutableStateOf(&quot;&quot;) }&#10;    val messages by chatbotViewModel.messages.collectAsState()&#10;    val isLoading by chatbotViewModel.isLoading.collectAsState()&#10;    val listState = rememberLazyListState()&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Scroll automatique vers le bas quand de nouveaux messages arrivent&#10;    LaunchedEffect(messages.size) {&#10;        if (messages.isNotEmpty()) {&#10;            listState.animateScrollToItem(messages.size - 1)&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.SmartToy,&#10;                            contentDescription = null,&#10;                            tint = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(&quot;Assistant Eventify&quot;)&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onMenuClick) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Menu,&#10;                            contentDescription = &quot;Menu&quot;,&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = Color(0xFF2196F3),&#10;                    titleContentColor = Color.White&#10;                )&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;                .background(Color(0xFFF5F5F5))&#10;        ) {&#10;            // Liste des messages&#10;            LazyColumn(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp),&#10;                state = listState,&#10;                contentPadding = PaddingValues(vertical = 16.dp)&#10;            ) {&#10;                items(messages) { message -&gt;&#10;                    ChatBubble(message = message)&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                }&#10;                &#10;                // Indicateur de chargement&#10;                if (isLoading) {&#10;                    item {&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            horizontalArrangement = Arrangement.Start&#10;                        ) {&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .size(36.dp)&#10;                                    .clip(CircleShape)&#10;                                    .background(Color(0xFF2196F3)),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                CircularProgressIndicator(&#10;                                    color = Color.White,&#10;                                    modifier = Modifier.size(20.dp),&#10;                                    strokeWidth = 2.dp&#10;                                )&#10;                            }&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Card(&#10;                                modifier = Modifier.widthIn(max = 280.dp),&#10;                                shape = RoundedCornerShape(4.dp, 16.dp, 16.dp, 16.dp),&#10;                                colors = CardDefaults.cardColors(containerColor = Color.White)&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;En train de réfléchir...&quot;,&#10;                                    modifier = Modifier.padding(12.dp),&#10;                                    color = Color.Gray,&#10;                                    fontSize = 14.sp&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Zone de saisie&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = RoundedCornerShape(topStart = 16.dp, topEnd = 16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = Color.White),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    OutlinedTextField(&#10;                        value = messageText,&#10;                        onValueChange = { messageText = it },&#10;                        modifier = Modifier.weight(1f),&#10;                        placeholder = { Text(&quot;Tapez votre message...&quot;) },&#10;                        shape = RoundedCornerShape(24.dp),&#10;                        colors = OutlinedTextFieldDefaults.colors(&#10;                            focusedBorderColor = Color(0xFF2196F3),&#10;                            cursorColor = Color(0xFF2196F3)&#10;                        ),&#10;                        maxLines = 3,&#10;                        enabled = !isLoading&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    FloatingActionButton(&#10;                        onClick = {&#10;                            if (messageText.isNotBlank() &amp;&amp; !isLoading) {&#10;                                chatbotViewModel.sendMessage(&#10;                                    token = token,&#10;                                    userMessage = messageText,&#10;                                    onError = { /* Géré par le ViewModel */ }&#10;                                )&#10;                                messageText = &quot;&quot;&#10;                            }&#10;                        },&#10;                        containerColor = if (isLoading) Color.Gray else Color(0xFF2196F3),&#10;                        modifier = Modifier.size(48.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.Send,&#10;                            contentDescription = &quot;Envoyer&quot;,&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ChatBubble(message: ChatMessage) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = if (message.isFromUser) Arrangement.End else Arrangement.Start&#10;    ) {&#10;        if (!message.isFromUser) {&#10;            // Avatar du bot&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(36.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color(0xFF2196F3)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.SmartToy,&#10;                    contentDescription = null,&#10;                    tint = Color.White,&#10;                    modifier = Modifier.size(20.dp)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;        }&#10;&#10;        Card(&#10;            modifier = Modifier.widthIn(max = 280.dp),&#10;            shape = RoundedCornerShape(&#10;                topStart = if (message.isFromUser) 16.dp else 4.dp,&#10;                topEnd = if (message.isFromUser) 4.dp else 16.dp,&#10;                bottomStart = 16.dp,&#10;                bottomEnd = 16.dp&#10;            ),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = if (message.isFromUser) Color(0xFF2196F3) else Color.White&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Text(&#10;                text = message.text,&#10;                modifier = Modifier.padding(12.dp),&#10;                color = if (message.isFromUser) Color.White else Color.DarkGray,&#10;                fontSize = 14.sp&#10;            )&#10;        }&#10;&#10;        if (message.isFromUser) {&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            // Avatar de l'utilisateur&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(36.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color(0xFF4CAF50)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;V&quot;,&#10;                    color = Color.White,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/participant/ParticipantEventDetailScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/participant/ParticipantEventDetailScreen.kt" />
              <option name="updatedContent" value="package com.eventify.app.ui.participant&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.Chat&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import com.eventify.app.model.Event&#10;import com.eventify.app.viewmodel.EventViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ParticipantEventDetailScreen(&#10;    event: Event,&#10;    userId: String,&#10;    userEmail: String,&#10;    token: String,&#10;    eventViewModel: EventViewModel,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var isParticipant by remember { mutableStateOf(event.participants?.contains(userId) ?: false) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var showSuccessDialog by remember { mutableStateOf(false) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(event.title) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Retour&quot;,&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = Color(0xFF2196F3),&#10;                    titleContentColor = Color.White&#10;                )&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;                .verticalScroll(rememberScrollState())&#10;        ) {&#10;            // Image placeholder / Header&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(200.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Card(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFF2196F3).copy(alpha = 0.1f)&#10;                    )&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Event,&#10;                            contentDescription = null,&#10;                            modifier = Modifier.size(80.dp),&#10;                            tint = Color(0xFF2196F3)&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                // Badge statut inscription&#10;                if (isParticipant) {&#10;                    AssistChip(&#10;                        onClick = { },&#10;                        label = { Text(&quot;Inscrit ✓&quot;, color = Color.White) },&#10;                        modifier = Modifier&#10;                            .align(Alignment.TopEnd)&#10;                            .padding(16.dp),&#10;                        colors = AssistChipDefaults.assistChipColors(&#10;                            containerColor = Color(0xFF4CAF50)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Contenu principal&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                // Titre&#10;                Text(&#10;                    text = event.title,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color(0xFF2196F3)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Informations de l'événement&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = CardDefaults.cardColors(containerColor = Color.White),&#10;                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                ) {&#10;                    Column(modifier = Modifier.padding(16.dp)) {&#10;                        // Date&#10;                        Row(verticalAlignment = Alignment.CenterVertically) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.CalendarToday,&#10;                                contentDescription = null,&#10;                                tint = Color(0xFF2196F3)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(12.dp))&#10;                            Column {&#10;                                Text(&#10;                                    text = &quot;Date&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = Color.Gray&#10;                                )&#10;                                Text(&#10;                                    text = event.date,&#10;                                    style = MaterialTheme.typography.bodyLarge&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                        // Lieu&#10;                        event.location?.let { location -&gt;&#10;                            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.LocationOn,&#10;                                    contentDescription = null,&#10;                                    tint = Color(0xFF2196F3)&#10;                                )&#10;                                Spacer(modifier = Modifier.width(12.dp))&#10;                                Column {&#10;                                    Text(&#10;                                        text = &quot;Lieu&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall,&#10;                                        color = Color.Gray&#10;                                    )&#10;                                    Text(&#10;                                        text = location,&#10;                                        style = MaterialTheme.typography.bodyLarge&#10;                                    )&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                        }&#10;&#10;                        // Organisateur&#10;                        event.createdBy?.let { creator -&gt;&#10;                            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.Person,&#10;                                    contentDescription = null,&#10;                                    tint = Color(0xFF2196F3)&#10;                                )&#10;                                Spacer(modifier = Modifier.width(12.dp))&#10;                                Column {&#10;                                    Text(&#10;                                        text = &quot;Organisateur&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall,&#10;                                        color = Color.Gray&#10;                                    )&#10;                                    Text(&#10;                                        text = creator.name,&#10;                                        style = MaterialTheme.typography.bodyLarge&#10;                                    )&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                        }&#10;&#10;                        // Participants&#10;                        Row(verticalAlignment = Alignment.CenterVertically) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Group,&#10;                                contentDescription = null,&#10;                                tint = Color(0xFF2196F3)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(12.dp))&#10;                            Column {&#10;                                Text(&#10;                                    text = &quot;Participants&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = Color.Gray&#10;                                )&#10;                                Text(&#10;                                    text = &quot;${event.participants?.size ?: 0} inscrits&quot;,&#10;                                    style = MaterialTheme.typography.bodyLarge&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Description&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = CardDefaults.cardColors(containerColor = Color.White),&#10;                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                ) {&#10;                    Column(modifier = Modifier.padding(16.dp)) {&#10;                        Text(&#10;                            text = &quot;Description&quot;,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = Color(0xFF2196F3)&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        Text(&#10;                            text = event.description ?: &quot;Aucune description disponible pour cet événement.&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = Color.DarkGray&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                // Message d'erreur&#10;                error?.let {&#10;                    Text(&#10;                        text = it,&#10;                        color = Color.Red,&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;                }&#10;&#10;                // Bouton d'inscription/désinscription&#10;                Button(&#10;                    onClick = {&#10;                        isLoading = true&#10;                        error = null&#10;                        if (isParticipant) {&#10;                            eventViewModel.leaveEvent(token, event._id,&#10;                                onSuccess = {&#10;                                    isParticipant = false&#10;                                    isLoading = false&#10;                                },&#10;                                onError = {&#10;                                    error = it&#10;                                    isLoading = false&#10;                                }&#10;                            )&#10;                        } else {&#10;                            eventViewModel.joinEvent(token, event._id,&#10;                                onSuccess = {&#10;                                    isParticipant = true&#10;                                    isLoading = false&#10;                                    showSuccessDialog = true&#10;                                },&#10;                                onError = {&#10;                                    error = it&#10;                                    isLoading = false&#10;                                }&#10;                            )&#10;                        }&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(56.dp),&#10;                    enabled = !isLoading,&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = if (isParticipant) Color(0xFFE53935) else Color(0xFF4CAF50)&#10;                    )&#10;                ) {&#10;                    if (isLoading) {&#10;                        CircularProgressIndicator(&#10;                            color = Color.White,&#10;                            modifier = Modifier.size(24.dp)&#10;                        )&#10;                    } else {&#10;                        Icon(&#10;                            imageVector = if (isParticipant) Icons.Default.Close else Icons.Default.Check,&#10;                            contentDescription = null,&#10;                            tint = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(&#10;                            text = if (isParticipant) &quot;Se désinscrire&quot; else &quot;S'inscrire à l'événement&quot;,&#10;                            color = Color.White,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Bouton contacter l'organisateur&#10;                OutlinedButton(&#10;                    onClick = { /* Ouvrir messagerie avec l'organisateur */ },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = ButtonDefaults.outlinedButtonColors(&#10;                        contentColor = Color(0xFF2196F3)&#10;                    )&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.AutoMirrored.Filled.Chat,&#10;                        contentDescription = null&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&quot;Contacter l'organisateur&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Dialog de confirmation d'inscription&#10;    if (showSuccessDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showSuccessDialog = false },&#10;            title = {&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.CheckCircle,&#10;                        contentDescription = null,&#10;                        tint = Color(0xFF4CAF50)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&quot;Inscription réussie !&quot;)&#10;                }&#10;            },&#10;            text = {&#10;                Text(&quot;Vous êtes maintenant inscrit à l'événement \&quot;${event.title}\&quot;. Vous recevrez une notification de rappel avant l'événement.&quot;)&#10;            },&#10;            confirmButton = {&#10;                TextButton(onClick = { showSuccessDialog = false }) {&#10;                    Text(&quot;OK&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/participant/ParticipantEventsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/participant/ParticipantEventsScreen.kt" />
              <option name="updatedContent" value="package com.eventify.app.ui.participant&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import com.eventify.app.model.Event&#10;import com.eventify.app.viewmodel.EventViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ParticipantEventsScreen(&#10;    eventViewModel: EventViewModel,&#10;    token: String,&#10;    userId: String,&#10;    userEmail: String,&#10;    onMenuClick: () -&gt; Unit,&#10;    onEventClick: (Event) -&gt; Unit&#10;) {&#10;    val events by eventViewModel.events.collectAsState()&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var showOnlyRegistered by remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        eventViewModel.loadEvents(token) { err -&gt;&#10;            error = err&#10;        }&#10;    }&#10;&#10;    // Filtrer les événements&#10;    val filteredEvents = events.filter { event -&gt;&#10;        val matchesSearch = event.title.contains(searchQuery, ignoreCase = true) ||&#10;                (event.description?.contains(searchQuery, ignoreCase = true) ?: false)&#10;        &#10;        val matchesRegistration = if (showOnlyRegistered) {&#10;            event.participants?.contains(userId) == true&#10;        } else true&#10;        &#10;        matchesSearch &amp;&amp; matchesRegistration&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Événements&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onMenuClick) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Menu,&#10;                            contentDescription = &quot;Menu&quot;,&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = Color(0xFF2196F3),&#10;                    titleContentColor = Color.White&#10;                )&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Barre de recherche&#10;            OutlinedTextField(&#10;                value = searchQuery,&#10;                onValueChange = { searchQuery = it },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                placeholder = { Text(&quot;Rechercher un événement...&quot;) },&#10;                leadingIcon = {&#10;                    Icon(Icons.Default.Search, contentDescription = &quot;Rechercher&quot;)&#10;                },&#10;                singleLine = true,&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF2196F3),&#10;                    cursorColor = Color(0xFF2196F3)&#10;                )&#10;            )&#10;&#10;            // Filtres&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                FilterChip(&#10;                    selected = !showOnlyRegistered,&#10;                    onClick = { showOnlyRegistered = false },&#10;                    label = { Text(&quot;Tous&quot;) },&#10;                    colors = FilterChipDefaults.filterChipColors(&#10;                        selectedContainerColor = Color(0xFF2196F3),&#10;                        selectedLabelColor = Color.White&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                FilterChip(&#10;                    selected = showOnlyRegistered,&#10;                    onClick = { showOnlyRegistered = true },&#10;                    label = { Text(&quot;Mes inscriptions&quot;) },&#10;                    colors = FilterChipDefaults.filterChipColors(&#10;                        selectedContainerColor = Color(0xFF4CAF50),&#10;                        selectedLabelColor = Color.White&#10;                    )&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Message d'erreur&#10;            val errorMsg = error ?: &quot;&quot;&#10;            if (&#10;                errorMsg.isNotBlank() &amp;&amp;&#10;                !errorMsg.contains(&quot;Unauthorized&quot;, ignoreCase = true) &amp;&amp;&#10;                !errorMsg.contains(&quot;401&quot;, ignoreCase = true) &amp;&amp;&#10;                !errorMsg.contains(&quot;403&quot;, ignoreCase = true)&#10;            ) {&#10;                Text(&#10;                    text = errorMsg,&#10;                    color = Color.Red,&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            // Liste des événements&#10;            if (filteredEvents.isEmpty()) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = if (showOnlyRegistered) &#10;                            &quot;Vous n'êtes inscrit à aucun événement&quot; &#10;                        else &#10;                            &quot;Aucun événement disponible&quot;,&#10;                        color = Color.Gray&#10;                    )&#10;                }&#10;            } else {&#10;                LazyColumn {&#10;                    items(filteredEvents) { event -&gt;&#10;                        ParticipantEventItem(&#10;                            event = event,&#10;                            isRegistered = event.participants?.contains(userId) == true,&#10;                            onClick = { onEventClick(event) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ParticipantEventItem(&#10;    event: Event,&#10;    isRegistered: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp)&#10;            .clickable(onClick = onClick),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = Color.White&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = event.title,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = Color(0xFF2196F3),&#10;                    fontWeight = FontWeight.Bold,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                &#10;                if (isRegistered) {&#10;                    AssistChip(&#10;                        onClick = { },&#10;                        label = { Text(&quot;Inscrit&quot;, color = Color.White) },&#10;                        colors = AssistChipDefaults.assistChipColors(&#10;                            containerColor = Color(0xFF4CAF50)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            &#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            &#10;            Text(&#10;                text = event.description ?: &quot;Pas de description&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = Color.Gray,&#10;                maxLines = 2&#10;            )&#10;            &#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            &#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot; ${event.date}&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = Color.DarkGray&#10;                )&#10;                &#10;                event.location?.let {&#10;                    Text(&#10;                        text = &quot; $it&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.DarkGray&#10;                    )&#10;                }&#10;            }&#10;            &#10;            // Nombre de participants&#10;            event.participants?.let { participants -&gt;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = &quot; ${participants.size} participant(s)&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = Color.Gray&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/participant/ParticipantMainScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/participant/ParticipantMainScreen.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.eventify.app.ui.participant&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material.icons.automirrored.filled.Chat&#10;import androidx.compose.material.icons.automirrored.filled.ExitToApp&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.eventify.app.model.Event&#10;import com.eventify.app.model.User&#10;import com.eventify.app.viewmodel.EventViewModel&#10;import com.eventify.app.viewmodel.ChatbotViewModel&#10;import com.eventify.app.viewmodel.MessageViewModel&#10;import com.eventify.app.network.RetrofitInstance&#10;import kotlinx.coroutines.launch&#10;&#10;sealed class ParticipantScreen {&#10;    object Events : ParticipantScreen()&#10;    object Profile : ParticipantScreen()&#10;    object Chatbot : ParticipantScreen()&#10;    object Messages : ParticipantScreen()&#10;    data class EventDetail(val event: Event) : ParticipantScreen()&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ParticipantMainScreen(&#10;    userName: String,&#10;    userEmail: String,&#10;    userId: String,&#10;    userToken: String,&#10;    eventViewModel: EventViewModel,&#10;    onLogout: () -&gt; Unit&#10;) {&#10;    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)&#10;    val scope = rememberCoroutineScope()&#10;    var currentScreen by remember { mutableStateOf&lt;ParticipantScreen&gt;(ParticipantScreen.Events) }&#10;    &#10;    // ViewModels pour les fonctionnalités&#10;    val chatbotViewModel = remember { ChatbotViewModel() }&#10;    val messageViewModel = remember { MessageViewModel() }&#10;    &#10;    // Liste des utilisateurs pour la messagerie&#10;    var users by remember { mutableStateOf&lt;List&lt;User&gt;&gt;(emptyList()) }&#10;    &#10;    // Charger les utilisateurs au démarrage&#10;    LaunchedEffect(Unit) {&#10;        try {&#10;            users = RetrofitInstance.api.getAllUsers(&quot;Bearer $userToken&quot;)&#10;        } catch (e: Exception) {&#10;            // Ignorer l'erreur&#10;        }&#10;    }&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = drawerState,&#10;        drawerContent = {&#10;            ModalDrawerSheet(&#10;                modifier = Modifier.width(280.dp)&#10;            ) {&#10;                // Header du Drawer avec profil&#10;                DrawerHeader(&#10;                    userName = userName,&#10;                    userEmail = userEmail,&#10;                    onProfileClick = {&#10;                        currentScreen = ParticipantScreen.Profile&#10;                        scope.launch { drawerState.close() }&#10;                    }&#10;                )&#10;&#10;                HorizontalDivider()&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Menu items&#10;                DrawerMenuItem(&#10;                    icon = Icons.Default.Event,&#10;                    label = &quot;Événements&quot;,&#10;                    selected = currentScreen is ParticipantScreen.Events,&#10;                    onClick = {&#10;                        currentScreen = ParticipantScreen.Events&#10;                        scope.launch { drawerState.close() }&#10;                    }&#10;                )&#10;&#10;                DrawerMenuItem(&#10;                    icon = Icons.Default.SmartToy,&#10;                    label = &quot;Chatbot IA&quot;,&#10;                    selected = currentScreen is ParticipantScreen.Chatbot,&#10;                    onClick = {&#10;                        currentScreen = ParticipantScreen.Chatbot&#10;                        scope.launch { drawerState.close() }&#10;                    }&#10;                )&#10;&#10;                DrawerMenuItem(&#10;                    icon = Icons.AutoMirrored.Filled.Chat,&#10;                    label = &quot;Messagerie&quot;,&#10;                    selected = currentScreen is ParticipantScreen.Messages,&#10;                    onClick = {&#10;                        currentScreen = ParticipantScreen.Messages&#10;                        scope.launch { drawerState.close() }&#10;                    }&#10;                )&#10;&#10;                Spacer(modifier = Modifier.weight(1f))&#10;&#10;                HorizontalDivider()&#10;&#10;                DrawerMenuItem(&#10;                    icon = Icons.AutoMirrored.Filled.ExitToApp,&#10;                    label = &quot;Déconnexion&quot;,&#10;                    selected = false,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        onLogout()&#10;                    },&#10;                    tint = Color.Red&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;            }&#10;        }&#10;    ) {&#10;        // Contenu principal&#10;        when (val screen = currentScreen) {&#10;            is ParticipantScreen.Events -&gt; ParticipantEventsScreen(&#10;                eventViewModel = eventViewModel,&#10;                token = userToken,&#10;                userId = userId,&#10;                userEmail = userEmail,&#10;                onMenuClick = { scope.launch { drawerState.open() } },&#10;                onEventClick = { event -&gt; currentScreen = ParticipantScreen.EventDetail(event) }&#10;            )&#10;            is ParticipantScreen.Profile -&gt; ParticipantProfileScreen(&#10;                userName = userName,&#10;                userEmail = userEmail,&#10;                onMenuClick = { scope.launch { drawerState.open() } },&#10;                onBack = { currentScreen = ParticipantScreen.Events }&#10;            )&#10;            is ParticipantScreen.Chatbot -&gt; ParticipantChatbotScreen(&#10;                token = userToken,&#10;                chatbotViewModel = chatbotViewModel,&#10;                onMenuClick = { scope.launch { drawerState.open() } }&#10;            )&#10;            is ParticipantScreen.Messages -&gt; ParticipantMessagesScreen(&#10;                token = userToken,&#10;                userId = userId,&#10;                messageViewModel = messageViewModel,&#10;                users = users,&#10;                onMenuClick = { scope.launch { drawerState.open() } }&#10;            )&#10;            is ParticipantScreen.EventDetail -&gt; ParticipantEventDetailScreen(&#10;                event = screen.event,&#10;                userId = userId,&#10;                userEmail = userEmail,&#10;                token = userToken,&#10;                eventViewModel = eventViewModel,&#10;                onBack = { currentScreen = ParticipantScreen.Events }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DrawerHeader(&#10;    userName: String,&#10;    userEmail: String,&#10;    onProfileClick: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(Color(0xFF2196F3))&#10;            .padding(24.dp)&#10;            .clickable { onProfileClick() }&#10;    ) {&#10;        Column {&#10;            // Avatar avec icône de profil&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(72.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color.White),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Person,&#10;                    contentDescription = &quot;Profile&quot;,&#10;                    modifier = Modifier.size(48.dp),&#10;                    tint = Color(0xFF2196F3)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            Text(&#10;                text = userName,&#10;                color = Color.White,&#10;                fontSize = 18.sp,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Text(&#10;                text = userEmail,&#10;                color = Color.White.copy(alpha = 0.8f),&#10;                fontSize = 14.sp&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;            Text(&#10;                text = &quot;Participant&quot;,&#10;                color = Color.White.copy(alpha = 0.7f),&#10;                fontSize = 12.sp,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DrawerMenuItem(&#10;    icon: ImageVector,&#10;    label: String,&#10;    selected: Boolean,&#10;    onClick: () -&gt; Unit,&#10;    tint: Color = Color(0xFF2196F3)&#10;) {&#10;    NavigationDrawerItem(&#10;        icon = {&#10;            Icon(&#10;                imageVector = icon,&#10;                contentDescription = label,&#10;                tint = if (selected) tint else Color.Gray&#10;            )&#10;        },&#10;        label = {&#10;            Text(&#10;                text = label,&#10;                color = if (selected) tint else Color.DarkGray,&#10;                fontWeight = if (selected) FontWeight.Bold else FontWeight.Normal&#10;            )&#10;        },&#10;        selected = selected,&#10;        onClick = onClick,&#10;        modifier = Modifier.padding(horizontal = 12.dp),&#10;        colors = NavigationDrawerItemDefaults.colors(&#10;            selectedContainerColor = tint.copy(alpha = 0.1f),&#10;            unselectedContainerColor = Color.Transparent&#10;        )&#10;    )&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/participant/ParticipantMessagesScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/participant/ParticipantMessagesScreen.kt" />
              <option name="updatedContent" value="package com.eventify.app.ui.participant&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.Send&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.eventify.app.model.Message&#10;import com.eventify.app.model.User&#10;import com.eventify.app.viewmodel.MessageViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ParticipantMessagesScreen(&#10;    token: String,&#10;    userId: String,&#10;    messageViewModel: MessageViewModel,&#10;    users: List&lt;User&gt;,&#10;    onMenuClick: () -&gt; Unit&#10;) {&#10;    var selectedUser by remember { mutableStateOf&lt;User?&gt;(null) }&#10;    val inbox by messageViewModel.inbox.collectAsState()&#10;    val conversation by messageViewModel.conversation.collectAsState()&#10;    val isLoading by messageViewModel.isLoading.collectAsState()&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Charger la boîte de réception au démarrage&#10;    LaunchedEffect(Unit) {&#10;        messageViewModel.loadInbox(token) { err -&gt; error = err }&#10;    }&#10;&#10;    if (selectedUser != null) {&#10;        ConversationScreen(&#10;            token = token,&#10;            currentUserId = userId,&#10;            otherUser = selectedUser!!,&#10;            messageViewModel = messageViewModel,&#10;            onBack = {&#10;                selectedUser = null&#10;                messageViewModel.clearConversation()&#10;            }&#10;        )&#10;    } else {&#10;        Scaffold(&#10;            topBar = {&#10;                TopAppBar(&#10;                    title = { Text(&quot;Messagerie&quot;) },&#10;                    navigationIcon = {&#10;                        IconButton(onClick = onMenuClick) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Menu,&#10;                                contentDescription = &quot;Menu&quot;,&#10;                                tint = Color.White&#10;                            )&#10;                        }&#10;                    },&#10;                    colors = TopAppBarDefaults.topAppBarColors(&#10;                        containerColor = Color(0xFF2196F3),&#10;                        titleContentColor = Color.White&#10;                    )&#10;                )&#10;            }&#10;        ) { padding -&gt;&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(padding)&#10;            ) {&#10;                // Barre de recherche&#10;                OutlinedTextField(&#10;                    value = searchQuery,&#10;                    onValueChange = { searchQuery = it },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    placeholder = { Text(&quot;Rechercher un utilisateur...&quot;) },&#10;                    leadingIcon = {&#10;                        Icon(Icons.Default.Search, contentDescription = &quot;Rechercher&quot;)&#10;                    },&#10;                    singleLine = true,&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = Color(0xFF2196F3),&#10;                        cursorColor = Color(0xFF2196F3)&#10;                    )&#10;                )&#10;&#10;                // Message d'erreur&#10;                error?.let {&#10;                    Text(&#10;                        text = it,&#10;                        color = Color.Red,&#10;                        modifier = Modifier.padding(horizontal = 16.dp)&#10;                    )&#10;                }&#10;&#10;                if (isLoading) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator(color = Color(0xFF2196F3))&#10;                    }&#10;                } else {&#10;                    // Filtrer les utilisateurs par recherche&#10;                    val filteredUsers = users.filter { user -&gt;&#10;                        user._id != userId &amp;&amp; // Ne pas s'afficher soi-même&#10;                        (searchQuery.isEmpty() || &#10;                         user.name.contains(searchQuery, ignoreCase = true) ||&#10;                         user.email.contains(searchQuery, ignoreCase = true))&#10;                    }&#10;&#10;                    if (filteredUsers.isEmpty()) {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.Chat,&#10;                                    contentDescription = null,&#10;                                    modifier = Modifier.size(64.dp),&#10;                                    tint = Color.Gray&#10;                                )&#10;                                Spacer(modifier = Modifier.height(16.dp))&#10;                                Text(&#10;                                    text = &quot;Aucun utilisateur trouvé&quot;,&#10;                                    color = Color.Gray,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                            }&#10;                        }&#10;                    } else {&#10;                        LazyColumn {&#10;                            items(filteredUsers) { user -&gt;&#10;                                UserItem(&#10;                                    user = user,&#10;                                    lastMessage = inbox.filter { &#10;                                        (it.sender._id == user._id || it.receiver._id == user._id)&#10;                                    }.maxByOrNull { it.createdAt },&#10;                                    onClick = { selectedUser = user }&#10;                                )&#10;                                HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun UserItem(&#10;    user: User,&#10;    lastMessage: Message?,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable(onClick = onClick)&#10;            .padding(16.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        // Avatar&#10;        Box(&#10;            modifier = Modifier&#10;                .size(50.dp)&#10;                .clip(CircleShape)&#10;                .background(Color(0xFF2196F3)),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Text(&#10;                text = user.name.first().toString().uppercase(),&#10;                color = Color.White,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 20.sp&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.width(16.dp))&#10;&#10;        Column(modifier = Modifier.weight(1f)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = user.name,&#10;                    fontWeight = FontWeight.Medium,&#10;                    fontSize = 16.sp,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                // Badge du rôle&#10;                AssistChip(&#10;                    onClick = { },&#10;                    label = { &#10;                        Text(&#10;                            text = user.role.replaceFirstChar { it.uppercase() },&#10;                            fontSize = 10.sp&#10;                        )&#10;                    },&#10;                    modifier = Modifier.height(24.dp)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;            Text(&#10;                text = lastMessage?.content ?: user.email,&#10;                color = Color.Gray,&#10;                fontSize = 14.sp,&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ConversationScreen(&#10;    token: String,&#10;    currentUserId: String,&#10;    otherUser: User,&#10;    messageViewModel: MessageViewModel,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    var messageText by remember { mutableStateOf(&quot;&quot;) }&#10;    val conversation by messageViewModel.conversation.collectAsState()&#10;    val isLoading by messageViewModel.isLoading.collectAsState()&#10;    val listState = rememberLazyListState()&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Charger la conversation&#10;    LaunchedEffect(otherUser._id) {&#10;        messageViewModel.loadConversation(token, otherUser._id) { }&#10;    }&#10;&#10;    // Scroll vers le bas quand de nouveaux messages arrivent&#10;    LaunchedEffect(conversation.size) {&#10;        if (conversation.isNotEmpty()) {&#10;            listState.animateScrollToItem(conversation.size - 1)&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(40.dp)&#10;                                .clip(CircleShape)&#10;                                .background(Color.White),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = otherUser.name.first().toString().uppercase(),&#10;                                color = Color(0xFF2196F3),&#10;                                fontWeight = FontWeight.Bold&#10;                            )&#10;                        }&#10;                        Spacer(modifier = Modifier.width(12.dp))&#10;                        Column {&#10;                            Text(&#10;                                text = otherUser.name,&#10;                                fontSize = 16.sp,&#10;                                maxLines = 1,&#10;                                overflow = TextOverflow.Ellipsis&#10;                            )&#10;                            Text(&#10;                                text = otherUser.role.replaceFirstChar { it.uppercase() },&#10;                                fontSize = 12.sp,&#10;                                color = Color.White.copy(alpha = 0.8f)&#10;                            )&#10;                        }&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Retour&quot;,&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = Color(0xFF2196F3),&#10;                    titleContentColor = Color.White&#10;                )&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;                .background(Color(0xFFF5F5F5))&#10;        ) {&#10;            // Messages&#10;            if (isLoading &amp;&amp; conversation.isEmpty()) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .fillMaxWidth(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator(color = Color(0xFF2196F3))&#10;                }&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .padding(horizontal = 16.dp),&#10;                    state = listState,&#10;                    contentPadding = PaddingValues(vertical = 16.dp)&#10;                ) {&#10;                    items(conversation) { message -&gt;&#10;                        MessageBubble(&#10;                            message = message,&#10;                            isFromCurrentUser = message.sender._id == currentUserId&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Zone de saisie&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(containerColor = Color.White),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    OutlinedTextField(&#10;                        value = messageText,&#10;                        onValueChange = { messageText = it },&#10;                        modifier = Modifier.weight(1f),&#10;                        placeholder = { Text(&quot;Tapez votre message...&quot;) },&#10;                        shape = RoundedCornerShape(24.dp),&#10;                        colors = OutlinedTextFieldDefaults.colors(&#10;                            focusedBorderColor = Color(0xFF2196F3),&#10;                            cursorColor = Color(0xFF2196F3)&#10;                        ),&#10;                        maxLines = 3&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    FloatingActionButton(&#10;                        onClick = {&#10;                            if (messageText.isNotBlank()) {&#10;                                messageViewModel.sendMessage(&#10;                                    token = token,&#10;                                    receiverId = otherUser._id,&#10;                                    content = messageText,&#10;                                    onSuccess = { messageText = &quot;&quot; },&#10;                                    onError = { }&#10;                                )&#10;                            }&#10;                        },&#10;                        containerColor = Color(0xFF2196F3),&#10;                        modifier = Modifier.size(48.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.Send,&#10;                            contentDescription = &quot;Envoyer&quot;,&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MessageBubble(&#10;    message: Message,&#10;    isFromCurrentUser: Boolean&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = if (isFromCurrentUser) Arrangement.End else Arrangement.Start&#10;    ) {&#10;        if (!isFromCurrentUser) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(36.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color(0xFF2196F3)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = message.sender.name.first().toString().uppercase(),&#10;                    color = Color.White,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;        }&#10;&#10;        Card(&#10;            modifier = Modifier.widthIn(max = 280.dp),&#10;            shape = RoundedCornerShape(&#10;                topStart = if (isFromCurrentUser) 16.dp else 4.dp,&#10;                topEnd = if (isFromCurrentUser) 4.dp else 16.dp,&#10;                bottomStart = 16.dp,&#10;                bottomEnd = 16.dp&#10;            ),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = if (isFromCurrentUser) Color(0xFF2196F3) else Color.White&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(12.dp)) {&#10;                Text(&#10;                    text = message.content,&#10;                    color = if (isFromCurrentUser) Color.White else Color.DarkGray,&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;        }&#10;&#10;        if (isFromCurrentUser) {&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(36.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color(0xFF4CAF50)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = message.sender.name.first().toString().uppercase(),&#10;                    color = Color.White,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/participant/ParticipantProfileScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/participant/ParticipantProfileScreen.kt" />
              <option name="updatedContent" value="package com.eventify.app.ui.participant&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ParticipantProfileScreen(&#10;    userName: String,&#10;    userEmail: String,&#10;    onMenuClick: () -&gt; Unit,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    var isEditing by remember { mutableStateOf(false) }&#10;    var editedName by remember { mutableStateOf(userName) }&#10;    var notificationsEnabled by remember { mutableStateOf(true) }&#10;    var emailNotifications by remember { mutableStateOf(true) }&#10;    var pushNotifications by remember { mutableStateOf(true) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Mon Profil&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onMenuClick) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Menu,&#10;                            contentDescription = &quot;Menu&quot;,&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;                },&#10;                actions = {&#10;                    IconButton(onClick = { isEditing = !isEditing }) {&#10;                        Icon(&#10;                            imageVector = if (isEditing) Icons.Default.Check else Icons.Default.Edit,&#10;                            contentDescription = if (isEditing) &quot;Sauvegarder&quot; else &quot;Modifier&quot;,&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = Color(0xFF2196F3),&#10;                    titleContentColor = Color.White&#10;                )&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;                .verticalScroll(rememberScrollState())&#10;        ) {&#10;            // Header avec avatar&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .background(Color(0xFF2196F3))&#10;                    .padding(32.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(100.dp)&#10;                            .clip(CircleShape)&#10;                            .background(Color.White),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Person,&#10;                            contentDescription = &quot;Avatar&quot;,&#10;                            modifier = Modifier.size(60.dp),&#10;                            tint = Color(0xFF2196F3)&#10;                        )&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    &#10;                    if (isEditing) {&#10;                        OutlinedTextField(&#10;                            value = editedName,&#10;                            onValueChange = { editedName = it },&#10;                            label = { Text(&quot;Nom&quot;, color = Color.White) },&#10;                            colors = OutlinedTextFieldDefaults.colors(&#10;                                focusedTextColor = Color.White,&#10;                                unfocusedTextColor = Color.White,&#10;                                focusedBorderColor = Color.White,&#10;                                unfocusedBorderColor = Color.White.copy(alpha = 0.7f),&#10;                                cursorColor = Color.White&#10;                            ),&#10;                            singleLine = true&#10;                        )&#10;                    } else {&#10;                        Text(&#10;                            text = userName,&#10;                            color = Color.White,&#10;                            fontSize = 24.sp,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                    &#10;                    Text(&#10;                        text = userEmail,&#10;                        color = Color.White.copy(alpha = 0.8f),&#10;                        fontSize = 14.sp&#10;                    )&#10;                    &#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    &#10;                    AssistChip(&#10;                        onClick = { },&#10;                        label = { Text(&quot;Participant&quot;, color = Color(0xFF2196F3)) },&#10;                        colors = AssistChipDefaults.assistChipColors(&#10;                            containerColor = Color.White&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Section Informations personnelles&#10;            ProfileSection(title = &quot;Informations personnelles&quot;) {&#10;                ProfileInfoItem(&#10;                    icon = Icons.Default.Person,&#10;                    label = &quot;Nom&quot;,&#10;                    value = userName&#10;                )&#10;                ProfileInfoItem(&#10;                    icon = Icons.Default.Email,&#10;                    label = &quot;Email&quot;,&#10;                    value = userEmail&#10;                )&#10;                ProfileInfoItem(&#10;                    icon = Icons.Default.Badge,&#10;                    label = &quot;Rôle&quot;,&#10;                    value = &quot;Participant&quot;&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Section Préférences de notification&#10;            ProfileSection(title = &quot;Préférences de notifications&quot;) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Notifications,&#10;                            contentDescription = null,&#10;                            tint = Color(0xFF2196F3)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        Text(&quot;Activer les notifications&quot;)&#10;                    }&#10;                    Switch(&#10;                        checked = notificationsEnabled,&#10;                        onCheckedChange = { notificationsEnabled = it },&#10;                        colors = SwitchDefaults.colors(&#10;                            checkedThumbColor = Color(0xFF2196F3),&#10;                            checkedTrackColor = Color(0xFF2196F3).copy(alpha = 0.5f)&#10;                        )&#10;                    )&#10;                }&#10;&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Mail,&#10;                            contentDescription = null,&#10;                            tint = Color(0xFF2196F3)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        Text(&quot;Notifications par email&quot;)&#10;                    }&#10;                    Switch(&#10;                        checked = emailNotifications,&#10;                        onCheckedChange = { emailNotifications = it },&#10;                        enabled = notificationsEnabled,&#10;                        colors = SwitchDefaults.colors(&#10;                            checkedThumbColor = Color(0xFF2196F3),&#10;                            checkedTrackColor = Color(0xFF2196F3).copy(alpha = 0.5f)&#10;                        )&#10;                    )&#10;                }&#10;&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.PhoneAndroid,&#10;                            contentDescription = null,&#10;                            tint = Color(0xFF2196F3)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        Text(&quot;Notifications push&quot;)&#10;                    }&#10;                    Switch(&#10;                        checked = pushNotifications,&#10;                        onCheckedChange = { pushNotifications = it },&#10;                        enabled = notificationsEnabled,&#10;                        colors = SwitchDefaults.colors(&#10;                            checkedThumbColor = Color(0xFF2196F3),&#10;                            checkedTrackColor = Color(0xFF2196F3).copy(alpha = 0.5f)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(32.dp))&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ProfileSection(&#10;    title: String,&#10;    content: @Composable ColumnScope.() -&gt; Unit&#10;) {&#10;    Column(modifier = Modifier.padding(horizontal = 16.dp)) {&#10;        Text(&#10;            text = title,&#10;            style = MaterialTheme.typography.titleMedium,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color(0xFF2196F3)&#10;        )&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            colors = CardDefaults.cardColors(containerColor = Color.White),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                content = content&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ProfileInfoItem(&#10;    icon: androidx.compose.ui.graphics.vector.ImageVector,&#10;    label: String,&#10;    value: String&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 8.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Icon(&#10;            imageVector = icon,&#10;            contentDescription = null,&#10;            tint = Color(0xFF2196F3)&#10;        )&#10;        Spacer(modifier = Modifier.width(16.dp))&#10;        Column {&#10;            Text(&#10;                text = label,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = Color.Gray&#10;            )&#10;            Text(&#10;                text = value,&#10;                style = MaterialTheme.typography.bodyLarge&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/taks/TaskListScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/ui/taks/TaskListScreen.kt" />
              <option name="originalContent" value="package com.eventify.app.ui.tasks&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.eventify.app.model.Task&#10;import com.eventify.app.model.TaskRequest&#10;import com.eventify.app.viewmodel.EventViewModel&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import com.eventify.app.model.User&#10;&#10;fun millisToIso(millis: Long): String {&#10;    val sdf = java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, java.util.Locale.getDefault())&#10;    sdf.timeZone = java.util.TimeZone.getTimeZone(&quot;UTC&quot;)&#10;    return sdf.format(java.util.Date(millis))&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TaskListScreen(&#10;    eventId: String,&#10;    token: String,&#10;    eventViewModel: EventViewModel,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    var tasks by remember { mutableStateOf&lt;List&lt;Task&gt;&gt;(emptyList()) }&#10;    var loading by remember { mutableStateOf(true) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var showEditDialog by remember { mutableStateOf(false) }&#10;    var currentTask by remember { mutableStateOf&lt;Task?&gt;(null) }&#10;    var participants by remember { mutableStateOf&lt;List&lt;User&gt;&gt;(emptyList()) }&#10;&#10;&#10;    // Chargement des tâches&#10;    LaunchedEffect(eventId) {&#10;        eventViewModel.getTasksForEvent(token, eventId,&#10;            onSuccess = {&#10;                tasks = it&#10;                loading = false&#10;            },&#10;            onError = {&#10;                error = it&#10;                loading = false&#10;            }&#10;        )&#10;        eventViewModel.loadParticipants(token, eventId,&#10;            onSuccess = { users -&gt; participants = users },&#10;            onError = { error = error ?: &quot;Erreur chargement participants&quot; }&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Tâches&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.Filled.ArrowBack, contentDescription = &quot;Retour&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        floatingActionButton = {&#10;            FloatingActionButton(onClick = {&#10;                currentTask = null // Création nouvelle tâche&#10;                showEditDialog = true&#10;            }) {&#10;                Text(&quot;+&quot;)&#10;            }&#10;        }&#10;    ) { padding -&gt;&#10;        Box(modifier = Modifier.padding(padding)) {&#10;            if (loading) {&#10;                CircularProgressIndicator(modifier = Modifier.fillMaxSize())&#10;            } else if (error != null) {&#10;                Text(&quot;Erreur : $error&quot;, color = MaterialTheme.colorScheme.error)&#10;            } else {&#10;                LazyColumn {&#10;                    items(tasks) { task -&gt;&#10;                        TaskItem(task = task,&#10;                            onEdit = {&#10;                                currentTask = task&#10;                                showEditDialog = true&#10;                            },&#10;                            onDelete = {&#10;                                eventViewModel.deleteTask(token, task._id,&#10;                                    onSuccess = {&#10;                                        tasks = tasks.filter { it._id != task._id }&#10;                                    },&#10;                                    onError = { error = it }&#10;                                )&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Dialog édition/creation tâche&#10;    if (showEditDialog) {&#10;        TaskEditDialog(&#10;            task = currentTask,&#10;            participants = participants,&#10;            onDismiss = { showEditDialog = false },&#10;            onSave = { title, desc, status, assignedTo, dueDate -&gt;&#10;                val req = TaskRequest(title, desc, status, assignedTo, dueDate?.let { millisToIso(it) });                if (currentTask == null) {&#10;                    eventViewModel.createTask(token, eventId, req,&#10;                        onSuccess = {&#10;                            showEditDialog = false&#10;                            eventViewModel.getTasksForEvent(token, eventId,&#10;                                onSuccess = { tasks = it },&#10;                                onError = { error = it }&#10;                            )&#10;                        },&#10;                        onError = { error = it }&#10;                    )&#10;                } else {&#10;                    eventViewModel.updateTask(token, currentTask!!._id, req,&#10;                        onSuccess = {&#10;                            showEditDialog = false&#10;                            eventViewModel.getTasksForEvent(token, eventId,&#10;                                onSuccess = { tasks = it },&#10;                                onError = { error = it }&#10;                            )&#10;                        },&#10;                        onError = { error = it }&#10;                    )&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TaskItem(task: Task, onEdit: () -&gt; Unit, onDelete: () -&gt; Unit) {&#10;    Card(modifier = Modifier&#10;        .fillMaxWidth()&#10;        .padding(8.dp)) {&#10;        Row(&#10;            Modifier.padding(16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Column {&#10;                Text(task.title, style = MaterialTheme.typography.titleMedium)&#10;                Text(task.description ?: &quot;&quot;, style = MaterialTheme.typography.bodySmall)&#10;                Text(&quot;Statut : ${task.status}&quot;, style = MaterialTheme.typography.bodySmall)&#10;                task.assignedTo?.let {&#10;                    Text(&quot;Assignée à: ${it.name} (${it.role})&quot;, style = MaterialTheme.typography.bodySmall)&#10;                }&#10;            }&#10;            Row {&#10;                IconButton(onClick = onEdit) {&#10;                    Icon(Icons.Filled.Edit, contentDescription = &quot;Modifier&quot;)&#10;                }&#10;                IconButton(onClick = onDelete) {&#10;                    Icon(Icons.Filled.Delete, contentDescription = &quot;Supprimer&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.eventify.app.ui.tasks&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.eventify.app.model.Task&#10;import com.eventify.app.model.TaskRequest&#10;import com.eventify.app.viewmodel.EventViewModel&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import com.eventify.app.model.User&#10;&#10;fun millisToIso(millis: Long): String {&#10;    val sdf = java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, java.util.Locale.getDefault())&#10;    sdf.timeZone = java.util.TimeZone.getTimeZone(&quot;UTC&quot;)&#10;    return sdf.format(java.util.Date(millis))&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TaskListScreen(&#10;    eventId: String,&#10;    token: String,&#10;    eventViewModel: EventViewModel,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    var tasks by remember { mutableStateOf&lt;List&lt;Task&gt;&gt;(emptyList()) }&#10;    var loading by remember { mutableStateOf(true) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var showEditDialog by remember { mutableStateOf(false) }&#10;    var currentTask by remember { mutableStateOf&lt;Task?&gt;(null) }&#10;    var participants by remember { mutableStateOf&lt;List&lt;User&gt;&gt;(emptyList()) }&#10;&#10;&#10;    // Chargement des tâches&#10;    LaunchedEffect(eventId) {&#10;        eventViewModel.getTasksForEvent(token, eventId,&#10;            onSuccess = {&#10;                tasks = it&#10;                loading = false&#10;            },&#10;            onError = {&#10;                error = it&#10;                loading = false&#10;            }&#10;        )&#10;        eventViewModel.loadParticipants(token, eventId,&#10;            onSuccess = { users -&gt; participants = users },&#10;            onError = { error = error ?: &quot;Erreur chargement participants&quot; }&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Tâches&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.Filled.ArrowBack, contentDescription = &quot;Retour&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        floatingActionButton = {&#10;            FloatingActionButton(onClick = {&#10;                currentTask = null // Création nouvelle tâche&#10;                showEditDialog = true&#10;            }) {&#10;                Text(&quot;+&quot;)&#10;            }&#10;        }&#10;    ) { padding -&gt;&#10;        Box(modifier = Modifier.padding(padding)) {&#10;            if (loading) {&#10;                CircularProgressIndicator(modifier = Modifier.fillMaxSize())&#10;            } else if (error != null) {&#10;                Text(&quot;Erreur : $error&quot;, color = MaterialTheme.colorScheme.error)&#10;            } else {&#10;                LazyColumn {&#10;                    items(tasks) { task -&gt;&#10;                        TaskItem(task = task,&#10;                            onEdit = {&#10;                                currentTask = task&#10;                                showEditDialog = true&#10;                            },&#10;                            onDelete = {&#10;                                eventViewModel.deleteTask(token, eventId, task._id,&#10;                                    onSuccess = {&#10;                                        tasks = tasks.filter { it._id != task._id }&#10;                                    },&#10;                                    onError = { error = it }&#10;                                )&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Dialog édition/creation tâche&#10;    if (showEditDialog) {&#10;        TaskEditDialog(&#10;            task = currentTask,&#10;            participants = participants,&#10;            onDismiss = { showEditDialog = false },&#10;            onSave = { title, desc, status, assignedTo, dueDate -&gt;&#10;                val req = TaskRequest(title, desc, status, assignedTo, dueDate?.let { millisToIso(it) });                if (currentTask == null) {&#10;                    eventViewModel.createTask(token, eventId, req,&#10;                        onSuccess = {&#10;                            showEditDialog = false&#10;                            eventViewModel.getTasksForEvent(token, eventId,&#10;                                onSuccess = { tasks = it },&#10;                                onError = { error = it }&#10;                            )&#10;                        },&#10;                        onError = { error = it }&#10;                    )&#10;                } else {&#10;                    eventViewModel.updateTask(token, eventId, currentTask!!._id, req,&#10;                        onSuccess = {&#10;                            showEditDialog = false&#10;                            eventViewModel.getTasksForEvent(token, eventId,&#10;                                onSuccess = { tasks = it },&#10;                                onError = { error = it }&#10;                            )&#10;                        },&#10;                        onError = { error = it }&#10;                    )&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TaskItem(task: Task, onEdit: () -&gt; Unit, onDelete: () -&gt; Unit) {&#10;    Card(modifier = Modifier&#10;        .fillMaxWidth()&#10;        .padding(8.dp)) {&#10;        Row(&#10;            Modifier.padding(16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Column {&#10;                Text(task.title, style = MaterialTheme.typography.titleMedium)&#10;                Text(task.description ?: &quot;&quot;, style = MaterialTheme.typography.bodySmall)&#10;                Text(&quot;Statut : ${task.status}&quot;, style = MaterialTheme.typography.bodySmall)&#10;                task.assignedTo?.let {&#10;                    Text(&quot;Assignée à: ${it.name} (${it.role})&quot;, style = MaterialTheme.typography.bodySmall)&#10;                }&#10;            }&#10;            Row {&#10;                IconButton(onClick = onEdit) {&#10;                    Icon(Icons.Filled.Edit, contentDescription = &quot;Modifier&quot;)&#10;                }&#10;                IconButton(onClick = onDelete) {&#10;                    Icon(Icons.Filled.Delete, contentDescription = &quot;Supprimer&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/viewmodel/ChatbotViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/viewmodel/ChatbotViewModel.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.eventify.app.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.eventify.app.model.ChatbotRequest&#10;import com.eventify.app.model.ChatbotResponse&#10;import com.eventify.app.network.RetrofitInstance&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class ChatMessage(&#10;    val id: Int,&#10;    val text: String,&#10;    val isFromUser: Boolean,&#10;    val timestamp: String = &quot;&quot;&#10;)&#10;&#10;class ChatbotViewModel : ViewModel() {&#10;&#10;    private val _messages = MutableStateFlow&lt;List&lt;ChatMessage&gt;&gt;(&#10;        listOf(&#10;            ChatMessage(&#10;                id = 0,&#10;                text = &quot;Bonjour !  Je suis l'assistant Eventify. Comment puis-je vous aider aujourd'hui ?&quot;,&#10;                isFromUser = false&#10;            )&#10;        )&#10;    )&#10;    val messages: StateFlow&lt;List&lt;ChatMessage&gt;&gt; = _messages&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading&#10;&#10;    // Envoyer un message au chatbot&#10;    fun sendMessage(token: String, userMessage: String, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            // Ajouter le message de l'utilisateur&#10;            val userMsg = ChatMessage(&#10;                id = _messages.value.size,&#10;                text = userMessage,&#10;                isFromUser = true&#10;            )&#10;            _messages.value = _messages.value + userMsg&#10;&#10;            _isLoading.value = true&#10;            try {&#10;                val request = ChatbotRequest(message = userMessage)&#10;                val response = RetrofitInstance.api.chatWithBot(&quot;Bearer $token&quot;, request)&#10;&#10;                // Ajouter la réponse du bot (utilise &quot;response&quot; du backend)&#10;                val botMsg = ChatMessage(&#10;                    id = _messages.value.size,&#10;                    text = response.response,&#10;                    isFromUser = false&#10;                )&#10;                _messages.value = _messages.value + botMsg&#10;            } catch (e: Exception) {&#10;                // En cas d'erreur, ajouter un message d'erreur&#10;                val errorMsg = ChatMessage(&#10;                    id = _messages.value.size,&#10;                    text = &quot;Désolé, je n'ai pas pu traiter votre demande. Veuillez réessayer. (${e.message})&quot;,&#10;                    isFromUser = false&#10;                )&#10;                _messages.value = _messages.value + errorMsg&#10;                onError(e.localizedMessage ?: &quot;Erreur de communication avec le chatbot&quot;)&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    // Réinitialiser la conversation&#10;    fun clearConversation() {&#10;        _messages.value = listOf(&#10;            ChatMessage(&#10;                id = 0,&#10;                text = &quot;Bonjour !  Je suis l'assistant Eventify. Comment puis-je vous aider aujourd'hui ?&quot;,&#10;                isFromUser = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/viewmodel/EventViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/viewmodel/EventViewModel.kt" />
              <option name="originalContent" value="package com.eventify.app.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.eventify.app.model.Event&#10;import com.eventify.app.model.EventRequest&#10;import com.eventify.app.model.Task&#10;import com.eventify.app.model.TaskRequest&#10;import com.eventify.app.model.User&#10;import com.eventify.app.network.RetrofitInstance&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;class EventViewModel : ViewModel() {&#10;    private val _events = MutableStateFlow&lt;List&lt;Event&gt;&gt;(emptyList())&#10;    val events: StateFlow&lt;List&lt;Event&gt;&gt; = _events&#10;&#10;    private val _selectedEvent = MutableStateFlow&lt;Event?&gt;(null)&#10;    val selectedEvent: StateFlow&lt;Event?&gt; = _selectedEvent&#10;&#10;    fun loadEvents(token: String, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val eventsList = RetrofitInstance.api.getEvents(&quot;Bearer $token&quot;)&#10;                _events.value = eventsList&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur de chargement&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadEventById(token: String, id: String, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val event = RetrofitInstance.api.getEventById(&quot;Bearer $token&quot;, id)&#10;                _selectedEvent.value = event&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur de chargement&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun createEvent(token: String, eventRequest: EventRequest, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                RetrofitInstance.api.createEvent(&quot;Bearer $token&quot;, eventRequest)&#10;                onSuccess()&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur de création&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateEvent(token: String, eventId: String, eventRequest: EventRequest, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                RetrofitInstance.api.updateEvent(&quot;Bearer $token&quot;, eventId, eventRequest)&#10;                onSuccess()&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur de modification&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteEvent(token: String, eventId: String, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = RetrofitInstance.api.deleteEvent(&quot;Bearer $token&quot;, eventId)&#10;                if (response.isSuccessful) {&#10;                    onSuccess()&#10;                } else {&#10;                    onError(&quot;Erreur à la suppression&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur inconnue&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun joinEvent(token: String, eventId: String, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = RetrofitInstance.api.joinEvent(&quot;Bearer $token&quot;, eventId)&#10;                if (response.isSuccessful) {&#10;                    onSuccess()&#10;                } else {&#10;                    onError(&quot;Erreur lors de l'inscription&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur inscription&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun leaveEvent(token: String, eventId: String, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = RetrofitInstance.api.leaveEvent(&quot;Bearer $token&quot;, eventId)&#10;                if (response.isSuccessful) {&#10;                    onSuccess()&#10;                } else {&#10;                    onError(&quot;Erreur lors de la désinscription&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur désinscription&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadParticipants(token: String, eventId: String, onSuccess: (List&lt;User&gt;) -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val participants = RetrofitInstance.api.getParticipants(&quot;Bearer $token&quot;, eventId)&#10;                onSuccess(participants)&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur chargement participants&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun createTask(token: String, eventId: String, taskRequest: TaskRequest, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                RetrofitInstance.api.createTask(&quot;Bearer $token&quot;, eventId, taskRequest)&#10;                onSuccess()&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur création tâche&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getTasksForEvent(token: String, eventId: String, onSuccess: (List&lt;Task&gt;) -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val tasks = RetrofitInstance.api.getTasksForEvent(&quot;Bearer $token&quot;, eventId)&#10;                onSuccess(tasks)&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur chargement tâches&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateTask(token: String, taskId: String, taskRequest: TaskRequest, onSuccess: (Task) -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val updatedTask = RetrofitInstance.api.updateTask(&quot;Bearer $token&quot;, taskId, taskRequest)&#10;                onSuccess(updatedTask)&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur mise à jour tâche&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteTask(token: String, taskId: String, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = RetrofitInstance.api.deleteTask(&quot;Bearer $token&quot;, taskId)&#10;                if (response.isSuccessful) {&#10;                    onSuccess()&#10;                } else {&#10;                    onError(&quot;Erreur suppression tâche&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur suppression tâche&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.eventify.app.viewmodel&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.eventify.app.model.Event&#13;&#10;import com.eventify.app.model.EventRequest&#13;&#10;import com.eventify.app.model.Task&#13;&#10;import com.eventify.app.model.TaskRequest&#13;&#10;import com.eventify.app.model.User&#13;&#10;import com.eventify.app.network.RetrofitInstance&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;&#13;&#10;class EventViewModel : ViewModel() {&#13;&#10;    private val _events = MutableStateFlow&lt;List&lt;Event&gt;&gt;(emptyList())&#13;&#10;    val events: StateFlow&lt;List&lt;Event&gt;&gt; = _events&#13;&#10;&#13;&#10;    private val _selectedEvent = MutableStateFlow&lt;Event?&gt;(null)&#13;&#10;    val selectedEvent: StateFlow&lt;Event?&gt; = _selectedEvent&#13;&#10;&#13;&#10;    fun loadEvents(token: String, onError: (String) -&gt; Unit) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val eventsList = RetrofitInstance.api.getEvents(&quot;Bearer $token&quot;)&#13;&#10;                _events.value = eventsList&#13;&#10;            } catch (e: Exception) {&#13;&#10;                onError(e.localizedMessage ?: &quot;Erreur de chargement&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun loadEventById(token: String, id: String, onError: (String) -&gt; Unit) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val event = RetrofitInstance.api.getEventById(&quot;Bearer $token&quot;, id)&#13;&#10;                _selectedEvent.value = event&#13;&#10;            } catch (e: Exception) {&#13;&#10;                onError(e.localizedMessage ?: &quot;Erreur de chargement&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun createEvent(token: String, eventRequest: EventRequest, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                RetrofitInstance.api.createEvent(&quot;Bearer $token&quot;, eventRequest)&#13;&#10;                onSuccess()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                onError(e.localizedMessage ?: &quot;Erreur de création&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updateEvent(token: String, eventId: String, eventRequest: EventRequest, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                RetrofitInstance.api.updateEvent(&quot;Bearer $token&quot;, eventId, eventRequest)&#13;&#10;                onSuccess()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                onError(e.localizedMessage ?: &quot;Erreur de modification&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun deleteEvent(token: String, eventId: String, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val response = RetrofitInstance.api.deleteEvent(&quot;Bearer $token&quot;, eventId)&#13;&#10;                if (response.isSuccessful) {&#13;&#10;                    onSuccess()&#13;&#10;                } else {&#13;&#10;                    onError(&quot;Erreur à la suppression&quot;)&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                onError(e.localizedMessage ?: &quot;Erreur inconnue&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun joinEvent(token: String, eventId: String, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val response = RetrofitInstance.api.joinEvent(&quot;Bearer $token&quot;, eventId)&#13;&#10;                if (response.isSuccessful) {&#13;&#10;                    onSuccess()&#13;&#10;                } else {&#13;&#10;                    onError(&quot;Erreur lors de l'inscription&quot;)&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                onError(e.localizedMessage ?: &quot;Erreur inscription&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun leaveEvent(token: String, eventId: String, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val response = RetrofitInstance.api.leaveEvent(&quot;Bearer $token&quot;, eventId)&#13;&#10;                if (response.isSuccessful) {&#13;&#10;                    onSuccess()&#13;&#10;                } else {&#13;&#10;                    onError(&quot;Erreur lors de la désinscription&quot;)&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                onError(e.localizedMessage ?: &quot;Erreur désinscription&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun loadParticipants(token: String, eventId: String, onSuccess: (List&lt;User&gt;) -&gt; Unit, onError: (String) -&gt; Unit) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val participants = RetrofitInstance.api.getParticipants(&quot;Bearer $token&quot;, eventId)&#13;&#10;                onSuccess(participants)&#13;&#10;            } catch (e: Exception) {&#13;&#10;                onError(e.localizedMessage ?: &quot;Erreur chargement participants&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun createTask(token: String, eventId: String, taskRequest: TaskRequest, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                RetrofitInstance.api.createTask(&quot;Bearer $token&quot;, eventId, taskRequest)&#13;&#10;                onSuccess()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                onError(e.localizedMessage ?: &quot;Erreur création tâche&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getTasksForEvent(token: String, eventId: String, onSuccess: (List&lt;Task&gt;) -&gt; Unit, onError: (String) -&gt; Unit) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val tasks = RetrofitInstance.api.getTasksForEvent(&quot;Bearer $token&quot;, eventId)&#13;&#10;                onSuccess(tasks)&#13;&#10;            } catch (e: Exception) {&#13;&#10;                onError(e.localizedMessage ?: &quot;Erreur chargement tâches&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updateTask(token: String, eventId: String, taskId: String, taskRequest: TaskRequest, onSuccess: (Task) -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val updatedTask = RetrofitInstance.api.updateTask(&quot;Bearer $token&quot;, eventId, taskId, taskRequest)&#10;                onSuccess(updatedTask)&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur mise à jour tâche&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteTask(token: String, eventId: String, taskId: String, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = RetrofitInstance.api.deleteTask(&quot;Bearer $token&quot;, eventId, taskId)&#10;                if (response.isSuccessful) {&#10;                    onSuccess()&#10;                } else {&#10;                    onError(&quot;Erreur suppression tâche&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur suppression tâche&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/viewmodel/MessageViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/viewmodel/MessageViewModel.kt" />
              <option name="updatedContent" value="package com.eventify.app.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.eventify.app.model.Message&#10;import com.eventify.app.model.SendMessageRequest&#10;import com.eventify.app.network.RetrofitInstance&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;class MessageViewModel : ViewModel() {&#10;    &#10;    private val _inbox = MutableStateFlow&lt;List&lt;Message&gt;&gt;(emptyList())&#10;    val inbox: StateFlow&lt;List&lt;Message&gt;&gt; = _inbox&#10;&#10;    private val _conversation = MutableStateFlow&lt;List&lt;Message&gt;&gt;(emptyList())&#10;    val conversation: StateFlow&lt;List&lt;Message&gt;&gt; = _conversation&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading&#10;&#10;    // Charger la boîte de réception (tous les messages)&#10;    fun loadInbox(token: String, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            try {&#10;                val messages = RetrofitInstance.api.getInbox(&quot;Bearer $token&quot;)&#10;                _inbox.value = messages&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur de chargement des messages&quot;)&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    // Charger une conversation avec un utilisateur spécifique&#10;    fun loadConversation(token: String, otherUserId: String, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            try {&#10;                val messages = RetrofitInstance.api.getConversation(&quot;Bearer $token&quot;, otherUserId)&#10;                _conversation.value = messages&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur de chargement de la conversation&quot;)&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    // Envoyer un message&#10;    fun sendMessage(&#10;        token: String,&#10;        receiverId: String,&#10;        content: String,&#10;        onSuccess: (Message) -&gt; Unit,&#10;        onError: (String) -&gt; Unit&#10;    ) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val request = SendMessageRequest(receiverId = receiverId, content = content)&#10;                val message = RetrofitInstance.api.sendMessage(&quot;Bearer $token&quot;, request)&#10;                // Ajouter le message à la conversation actuelle&#10;                _conversation.value = _conversation.value + message&#10;                onSuccess(message)&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur d'envoi du message&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Réinitialiser la conversation&#10;    fun clearConversation() {&#10;        _conversation.value = emptyList()&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/eventify/app/viewmodel/NotificationViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/eventify/app/viewmodel/NotificationViewModel.kt" />
              <option name="updatedContent" value="package com.eventify.app.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.eventify.app.model.Notification&#10;import com.eventify.app.network.RetrofitInstance&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;class NotificationViewModel : ViewModel() {&#10;    &#10;    private val _notifications = MutableStateFlow&lt;List&lt;Notification&gt;&gt;(emptyList())&#10;    val notifications: StateFlow&lt;List&lt;Notification&gt;&gt; = _notifications&#10;&#10;    private val _unreadCount = MutableStateFlow(0)&#10;    val unreadCount: StateFlow&lt;Int&gt; = _unreadCount&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading&#10;&#10;    // Charger les notifications&#10;    fun loadNotifications(token: String, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            try {&#10;                val notifList = RetrofitInstance.api.getMyNotifications(&quot;Bearer $token&quot;)&#10;                _notifications.value = notifList&#10;                _unreadCount.value = notifList.count { !it.read }&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur de chargement des notifications&quot;)&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    // Marquer une notification comme lue&#10;    fun markAsRead(token: String, notificationId: String, onSuccess: () -&gt; Unit, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = RetrofitInstance.api.markNotificationAsRead(&quot;Bearer $token&quot;, notificationId)&#10;                if (response.isSuccessful) {&#10;                    // Mettre à jour localement&#10;                    _notifications.value = _notifications.value.map { notif -&gt;&#10;                        if (notif._id == notificationId) notif.copy(read = true) else notif&#10;                    }&#10;                    _unreadCount.value = _notifications.value.count { !it.read }&#10;                    onSuccess()&#10;                } else {&#10;                    onError(&quot;Erreur lors du marquage&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                onError(e.localizedMessage ?: &quot;Erreur&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Marquer toutes comme lues&#10;    fun markAllAsRead(token: String, onError: (String) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            val unreadNotifs = _notifications.value.filter { !it.read }&#10;            for (notif in unreadNotifs) {&#10;                try {&#10;                    RetrofitInstance.api.markNotificationAsRead(&quot;Bearer $token&quot;, notif._id)&#10;                } catch (e: Exception) {&#10;                    // Continuer même en cas d'erreur&#10;                }&#10;            }&#10;            // Recharger les notifications&#10;            loadNotifications(token, onError)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>